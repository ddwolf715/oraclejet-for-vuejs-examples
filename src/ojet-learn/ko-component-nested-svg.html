<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Knockout Learning</title>

    <meta charset="UTF-8">
  </head>
  <body>

    <template id="my-component-template">
      <circle cx="100" cy="100" r="80"></circle>
    </template>
    <div id="app">
      <svg width="200" height="200">

        <!-- The KO bind/connect this element, but the element node will remain and
        will not work with svn as container?
        <my-component></my-component>
        -->

        <!-- Here is a KO Workaround is to use comment based binding without container
        But we still need a custom template loader to refresh due to svg is
        tricky to reload!

        Are these related?
        - https://github.com/knockout/knockout/issues/820
        - http://jsfiddle.net/dflor003/6kwmrLs8/
          (someone able to get it to work using a custom svgTemplateLoader!)
        -->
        <!-- ko component: {name: "my-component"} -->
        <!-- /ko -->
      </svg>
    </div>

    <script type="text/javascript" src="https://unpkg.com/requirejs@2.3.6/require.js"></script>

    <script>
      requirejs.config({
        paths:{
          'knockout': 'https://unpkg.com/knockout@3.5.1/build/output/knockout-latest',
          'jquery': 'https://unpkg.com/jquery@3.4.1/dist/jquery'
        }
      });
      require([
              'knockout', 'jquery'],
              function(ko, $){

        function MyComponent() {
          console.log("my-component has binded");
        }

        function AppVM() {
          this.message = "Hello World";
        }

        /** This is from: http://jsfiddle.net/dflor003/6kwmrLs8/ */
        function setupSvgTemplateLoader() {

          /* Custom template loader */
          function SvgTemplateLoader() {
          }
          SvgTemplateLoader.prototype = {
            parseSvgTemplate: function(templateString) {
              var svgWrappedTemplate = '<svg>' + templateString + '</svg>',
                      $wrapper = $('<div>').html(svgWrappedTemplate),
                      $svg = $wrapper.children('svg');

              return $svg[0].childNodes;
            },

            loadTemplate: function (name, templateConfig, callback) {
              if (!templateConfig || !templateConfig.svgTemplate) {
                callback(null); // Don't process if we don't have a svgTemplateName
                return;
              }

              var self = this;
              self.fetchTemplate(templateConfig.svgTemplate, function (templateString) {
                var parsedTemplate = self.parseSvgTemplate(templateString);
                callback(parsedTemplate);
              });
            },

            fetchTemplate: function (templateId, callback) {
              var self = this,
                  $templateElement = $(document.getElementById(templateId));

              if ($templateElement.length) {
                callback($templateElement.html());
                return;
              }

              //infuser.get(templateId, callback);
            }
          };
          // Push template loader to the front of the loader list
          ko.components.loaders.unshift(new SvgTemplateLoader());
        }

        $(function() {
          setupSvgTemplateLoader();

          ko.components.register('my-component', {
            viewModel: MyComponent,
            template: { svgTemplate: 'my-component-template' }
          });

          ko.applyBindings(new AppVM(), document.getElementById("app"));
        });
      });
    </script>
  </body>
</html>
